---
title: "Untitled"
output: github_document
date: '`r format(Sys.time(), "%d %B, %Y")`'
bibliography: references.bib
knit: worcs::cite_all
---

```{r setup, include=FALSE}
library("worcs")
# We recommend that you prepare your raw data for analysis in 'prepare_data.R',
# and end that file with either open_data(yourdata), or closed_data(yourdata).
# Then, uncomment the line below to load the original or synthetic data
# (whichever is available), to allow anyone to reproduce your code:
# load_data()
knitr::opts_chunk$set(echo = TRUE)
```

This manuscript uses the Workflow for Open Reproducible Code in Science [@vanlissaWORCSWorkflowOpen2021] to ensure reproducibility and transparency. All code <!--and data--> are available at <tutorial_IC2S22025_workflow>.

This is an example of a non-essential citation [@@vanlissaWORCSWorkflowOpen2021]. If you change the rendering function to `worcs::cite_essential`, it will be removed.

<!--The function below inserts a notification if the manuscript is knit using synthetic data. Make sure to insert it after load_data().-->
`r notify_synthetic()`

## GitHub Documents

This is an R Markdown format used for publishing markdown documents to GitHub. When you click the **Knit** button all R code chunks are run and a markdown file (.md) suitable for publishing to GitHub is generated.

## Including Code

You can include R code in the document as follows:

```{r cars}
summary(cars)
```

## Including Plots

You can also embed plots, for example:

```{r pressure, echo=FALSE}
plot(pressure)
```

Note that the `echo = FALSE` parameter was added to the code chunk to prevent printing of the R code that generated the plot.


Class work

Install packages
```{r}
install.packages("theorytools", prompt = FALSE)
install.packages("dagitty", prompt = FALSE)
install.packages("tidySEM", prompt = FALSE)
```



Load packages

```{r}
library(theorytools)
library(dagitty)
library(tidySEM)
```

```{r}
theorytools::download_theory("10.5281/zenodo.15648655", path = "theory")

```

3. Load the FAIR Theory
This FAIR theory is an augmented DAG, which can be read using the dagitty package.

The vignette Specifying Augmented Directed Acyclic Graphs describes what augmented DAGs are.

Such DAGs are particularly useful for computational social science studies, because the theorytools package contains methods to convert augmented DAGs to generative models.

Now, letâ€™s load the augmented DAG. Note: when running this code from a code chunk in your Rmarkdown file, you must use the file path ../theory/sdt.txt to go back to the parent directory, because the manuscript and the theory are both in different subdirectories. If you run it interactively instead, you are already inside the parent directory, and you can use the path theory/sdt.txt.


```{r}
sdt <- dagitty::dagitty(paste(readLines("../theory/sdt.txt"), collapse = "\n"))
```


Then, we can plot the model using the tidySEM package. Get a basic plot by running graph_sem(sdt):


```{r}
tidySEM::graph_sem(sdt)
```

Simulating data

```{r}
set.seed(1)
theorytools::simulate_data(sdt, n = 5)
```

Simplifying the Model
Suppose we are interested in studying the effect of intrinsic motivation on well-being. Even if our research is grounded in SDT, we do not need the entire theory to hypothesize about this specific relationship. We can use the DAG to derive a restricted version of the theory that includes all variables that might confound the relationship of interest between intrinsic motivation and well-being:

```{r}

sdt_pruned <- theorytools:::prune_dag(sdt,
                                      exposure = "intrinsic_motivation",
                                      outcome = "wellbeing")
sdt_pruned
```

```{r}
set.seed(1)
df <- theorytools::simulate_data(sdt_pruned, n = 100)
head(df)
```

```{r}
res <- lm(wellbeing ~ intrinsic_motivation + needs, data = df)
summary(res)
```

Using worcs with targets: Sustainable Reproducibility
One of the main tenets of open and reproducible science is the ability to re-run all analyses from raw data to published output, to ensure that results are still valid. However, in computationally intensive projects, re-running unchanged code repeatedly can be redundant, slow, and wasteful.

The targets package reduces unnecessary compute by breaking down an analysis pipeline into steps that explicitly reference one another, where each step is only re-computed if either the step changed, or its inputs changed. Reducing unnecessary computation speeds up the analysis process and reduces the carbon footprint of analyses (Gupta et al. 2021).

By combining worcs with targets, we get the best of both worlds:

worcs is used to create a fully reproducible research archive;
targets ensures that redundant steps in a reproducible analysis pipeline are not unnecessarily re-computed.


```{r}

```


Power analysis, from wich effect size we observe significant results 


With simultaion, theory base we could wrk on this. 


```{r}
install.packages("targets", prompt = FALSE)
install.packages("tarchetypes", prompt = FALSE)
```


```{r}
worcs::add_targets()
```

